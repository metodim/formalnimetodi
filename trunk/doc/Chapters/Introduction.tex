\section{Introduction}

(The tool is a Java executable jar library with very simple user interface...)

TODO: Rewrite the introduction to represent a longer summary of the report. 

\subsection{Related work} 

In the past two decades different tools for modeling, specification and verification of concurrent reactive systems 

The Edinburgh Concurrency Workbench (CWB) is a tool for analysis of cuncurrent systems. CWB allows for equivalence, preorder and model checking using a variety of different process semantics. It also allows defining of behaviours in an extended version of CCS and perform various analysis of these behaviours, such as checking various semantic equivalences for examples checking if two processes (agents in CWB) are strongly or weakly bisimilar \cite{CWB}. Although CWB covers much of the functionality of our tool and more, CWB has a command interpreter interface that is more difficult to work with, unlike our tool that has a Graphical User Interface (GUI), and is very intuitive. As far as we know the CWB does not have the functionality for exporting LTS graphs in Aldebaran format, that our tool has. We have used the CWB many times while testing our tool, for checking CCS validity and also testing algorithms for strong and weak bisimularity of LTS graphs. 

The micro Common Representation Language 2 (mCRL2), successor of µCRL, is a formal specification language that can be used to specify and analyse the behaviour of distrubuted systems and protocols. Its accompanying toolset contains extensive collection of tools to automatically translate any mCRL2 specification to a linear process, manipulate and simulate linear processes, generate the state space associated with a linear process, manipulate and visualize state spaces, generate a PBES from a formula and a linear process, generate a BES from PBES and manipulate and solve (P)BESs \cite{mCRL2}. All mCRL2 tools can be used from the command line, but mCRL2 has an enhanced Graphical User Interface (GUI) as well which makes it very user-friendly and easy and to use. However, to our knowledge, mCRL2 does not provide the possibility to define systems' behaviour in the CCS process language nor to specify systems' properties using HML logic, functionalities that are implemented in the very initial version of our tool. Also, even though mCRL2 supports minimization modulo strong and weak bisimulation equivalence, it does not output the computed bisimulation, feature that we have implemented in our tool.
 
\subsection{Outline} The contributions of this paper are organized as follows. In the next section we give introduction to some of the basic terminology used throughout the report. The third section is devoted to the implementation of the CCS process language and generation of Labelled Transition Systems as a semantic model of process expressions, and it also discusses some of the choices made during the implementation. Section four describes the process of reducing the size of the state space of an LTS as well as checking the equivalence between two LTSs with respect to behavioural relations such as strong bisimilarity and observational equivalence (weak bisimilarity). It includes implementation details of two algorithms for computing strong bisimulation equivalence, the naive algorithm and the advanced algorithm due to Fernandez, as well as description of the saturation technique together with a respective algorithm  for saturating an LTS with which the problem of computing weak bisimilarity is reduced to computing strong bisimilarity over the saturated systems. Section five explains how the implementation of Hennesy-Milner Logic (HML) works and gives implementation details for the $U_{w}$ and $U_{s}$ operators. Next we illustrate the application of the tool for modeling, specification and verification of some classical examples. These classical examples include the Alternating Bit Protocol and Peterson's mutual exclusion algorithm. Finally, we give some conclusions and some directions for future development of the tool. We also include four appendixes. The first appendix contains the experimental results we got with analysis of the running times of our implementations of the two algorithms for computing bisimulation equivalence. The second one shows the syntax diagram for the grammar that recognizes CCS expressions . And the last appendix includes some visual illustration of the tool's usage via screenshots of the graphical application.
