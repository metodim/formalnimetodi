\subsection{Alternating Bit Protocol - Modelling, Specification and Verification}

The alternating bit protocol is a simple yet effective protocol (usually used as a test case), designed to ensure reliable communication through unreliable transmission mediums, and it is used for managing the retransmission of lost messages \cite{ReactiveSystems3}\cite{Kulick}.

\subsubsection{Modelling and Specification.}
The representation of the Alternating Bit Protocol (abbreviated as ABP in the rest of the section) is shown bellow, and it consists of a $sender$ $S$, a $receiver$ $R$ and two channels $transport$ $T$ and $acknowledge$ $A$. 

\begin{figure}[h]
\centering
\includegraphics[width=4.5in]{abp}
\caption{Alternating Bit Protocol}
\label{fig:abp}
\end{figure}

All of the transitions in the ABP are internal synchronization and the only visible transitions are $deliver$ and $accept$, which can occur only sequentially. 

ABP should act as a simple buffer, therefore its CCS specification is defined as follows:
\begin{equation}\label{eq:abp_spec}
	\begin{array}{lcl}
		Buf = accept.Buf'\\
		Buf' = \overline{deliver}.Buf
	\end{array}
\end{equation}

Messages are sent from a sender $S$ to a receiver $R$. Channel from $S$ to $R$ is initialized and there are no messages in transit. There is no direct communication between the sender $S$ and the receiver $R$, and all messages must travel trough the medium ($transport$ and $acknowledge$ channel). The functioning of ABP can be described as follows:
\begin{enumerate}
	\item Each message sent by $S$ contains the protocol bit, 0 or 1. When a sender $S$ sends a message, it sends it repeatedly (with its corresponding bit) until receiving an acknowledgment ($ack0$ or $ack1$) from a receiver $R$ that contains the same protocol bit as the message being sent. Therefore, the behaviour of the process representing the sender can be described as:
				\begin{equation*}\label{send_imp}
				    \begin{array}{lcl}
							S = \overline{send0}.S+ack0.accept.S_{1}+ack1.S \\
							S_{1}=\overline{send1}.S_{1}+ack1.accept.S+ack0.S_{1}				  
						\end{array}
				\end{equation*}
	      The transport channel transmits the message to the receiver, but it may lose the message (lossy channel) or transmit it several times (chatty channel). Therefore, the description of the behaviour of the process representing the transport channel is given with the CCS expression:
	      \begin{equation*}\label{trans_imp}
	      	\begin{array}{lcl}
						T=send0.\left(T+T_{1}\right)+send1.\left(T+T_{2}\right)\\
						T_{1}=\overline{receive0}.\left(T+T_{1}\right)\\
						T_{2}=\overline{receive1}.\left(T+T_{2}\right)
					\end{array}
				\end{equation*}
  \item When $R$ receives a message, it sends a reply to $S$ that includes the protocol bit of the message received. When a message is received for the first time, the receiver delivers it for processing, while subsequent messages with the same bit are simply acknowledged. That yields the following CCS expression for the receiver:
  			\begin{equation*}\label{rec_imp}
				    \begin{array}{lcl}
							R=receive0.\overline{deliver}.R_{1}+\overline{reply1}.R+receive1.R \\
							R_{1}=receive1.\overline{deliver}.R+\overline{reply0}.R_{1}+receive0.R_{1}			  
						\end{array}
				\end{equation*}
        Again the acknowledgement channel sends the $ack$ to sender, and it can also acknowledge it several times or lose it on the way to the sender. Therefore the ackowledgement channel and its behaviour can be described as follows:
        \begin{equation*}\label{trans_imp}
	      	\begin{array}{lcl}
						A=reply0.\left(A+A_{1}\right)+reply1.\left(A+A_{2}\right)\\
						A_{1}=\overline{ack0}.\left(A+A_{1}\right)\\
						A_{2}=\overline{ack1}.\left(A+A_{2}\right)
					\end{array}
				\end{equation*}
  \item When $S$ receives an acknowledgment containing the same bit as the message it is currently transmitting, it stops transmitting that message, flips the protocol bit, and repeats the protocol for the next message.\cite{Kulick}\cite{ProcessAlgebraParallel}
\end{enumerate}

Having described the behaviour of the ABP components, the CCS process term describing the behaviour of the protocol as a whole can be obtained as a parallel composition of the processes describing the sender, the transport channel, the receiver and the acknowledgement channel, restricted on the set of actions:
\begin{equation*}
  L = \left(send0,send1,receive0,receive1,reply0,reply1,ack0,ack1\right)
\end{equation*}

Now, the CCS implementation of the Alternating Bit Protocol is given as:
\begin{equation}\label{abp_imp}
	ABP \stackrel{def}{=}\left(S|T|R|A\right)\backslash L
\end{equation}

\subsubsection{Verification.} In order to verify the Alternating Bit Protocol, we need to prove that the implementation meets the specification with respect to some behavioural equivalence. We will show that an observational equivalence between $Buf$ and $ABP$ can be found, i.e. that $ABP\approx Imp$. For that purpose, first we use our tool to obtain the labelled graphs corresponding to the CCS representations of $Buf$ and $ABP$, and afterwards we perform a comparison of the LTSs modulo weak bisimilarity which yields a positive answer about the existance of weak bisimulation equivalence between $Buf$ and $ABP$.

The weak bisimulation equivalence obtained by running any of the two bisimulation algorithms implemented in our tool over the saturated LTSs is given in Table \ref{table3}:

\begin{table}
\begin{tabular}{| p{6.5cm} | p{3.5cm} | }
	
  \hline                       
	ABP implementation states &
	ABP specification states
	\\ \hline
	
$\left(S|T|R|A\right)\backslash L$ & \\
$\left(S|\left(T+T1\right)|R|A\right)\backslash L$ & \\
$\left(S|\left(T+T1\right)|R|\left(A+A2\right)\right)\backslash L$ & \\
$\left(S|T|R|\left(A+A2\right)\right)\backslash L$ & \\
$\left(S|\left(T+T1\right)|\overline{deliver}.R1|A\right)\backslash L$ & \\
$\left(S|\left(T+T1\right)|\overline{deliver}.R1|\left(A+A2\right)\right)\backslash L$ & \\
$\left(S1|\left(T+T1\right)|R1|\left(A+A1\right)\right)\backslash L$ & \\
$\left(S1|\left(T+T2\right)|\overline{deliver}.R|\left(A+A1\right)\right)\backslash L$ & \\
$\left(S1|\left(T+T2\right)|R1|\left(A+A1\right)\right)\backslash L$ & \\
$\left(S|\left(T+T2\right)|R|\left(A+A2\right)\right)\backslash L$ &
  $Buf$   
  \\ \hline
   
$\left(accept.S1|\left(T+T1\right)|R1|\left(A+A1\right)\right)\backslash L$ & \\ 
$\left(S|\left(T+T1\right)|R1|\left(A+A1\right)\right)\backslash L$ & \\
$\left(S|\left(T+T1\right)|R1|\left(A+A2\right)\right)\backslash L$ & \\
$\left(S|\left(T+T1\right)|R1|A\right)\backslash L$ & \\
$\left(S1|\left(T+T2\right)|R|\left(A+A2\right)\right)\backslash L$ & \\
$\left(accept.S|\left(T+T2\right)|R|\left(A+A2\right)\right)\backslash L$ & \\
$\left(S1|\left(T+T2\right)|R|\left(A+A1\right)\right)\backslash L$ &
  $Buf'$
  \\ \hline  
\end{tabular}
\\
\caption{Verification of Alternating Bit Protocol using weak bisimilarity (observational equivalence)}
\label{table3}
\end{table}
