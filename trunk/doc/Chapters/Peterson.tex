\subsection{Peterson's algorithm - Modeling,  Specification and Testing}

Peterson's algorithm \cite{Peterson} is a simple algorithm designed to ensure mutual exclusion between two processes without any special hardware support. It represents a simple refinement of ideas from earlier mutex algorithms such as Dekker's algorithm \cite{Dekker}. Mutual exclusion (often abbreviated as mutex) algorithms are used in concurrent programming to avoid the simultaneous use of a common resource by critical sections. A critical section is a piece of code in which a process or thread accesses a common resource. 

\subsubsection{Modeling and Specification.}In Peterson's algorithm for mutual exclusion, there are:
\begin{itemize}
  \item Two processes $P_{1}$ and $P_{2}$ that want to access the same resource, i.e. eneter the critical section;
	\item Two shared variables $b_{1}$ and $b_{2}$ which indicate whether process $P_{1}$ and process $P_{2}$ are trying to enter the critical section;
	\item A shared integer variable $k$ that can take one of the values 1 or 2 and indicates which process is next to enter the critical section;
\end{itemize}

The boolean variables $b_{1}$ and $b_{2}$ are initialized to values $'false'$ because neither of the processes is interested yet to enter the critical section, whereas the initial value of $k$ is arbitrary. 

In order to ensure mutual exclusion, each process $P_{i}$, $i\in\left\{1,2\right\}$, executes the following algorithm presented in pseudocode, where $j$ denotes the index of the other process. 

\begin{algorithm}
\caption{Peterson's algorithm pseudocode}
\begin{algorithmic}
\WHILE{$true$} 
	\STATE '<noncritical section>';
	\STATE $b_{i} \gets true$;
	\STATE $k \gets j$;
	\WHILE {$\left(b_{j} and k = j\right)$}
		 \STATE skip;
	\ENDWHILE
	\STATE '<critical section>';
	\STATE $b_{i} \gets false$;
\ENDWHILE
\end{algorithmic}
\end{algorithm}

The desired behaviour of the Peterson's algorithm is as the one of any simple mutex algorithm. Initially, both processes enter their critical sections, however once one of the processes has entered its critical section, the other process cannot enter its own critical section until the first process has exited its critical section. Therefore, a suitable CCS specification of the behaviour of a mutual exclusion algorithm like Peterson's is given as follows:
\begin{equation}
	MutexSpec = enter1.exit1.MutexSpec + enter2.exit2.MutexSpec
\end{equation}

Modeling the algorithm of Peterson includes, among other tasks, translation of the algorithm's pseudocode description of the behaviour of the processes $P_{1}$ and $P_{2}$ into the model of CCS or LTSs. 

Following the message-passing paradigm on which CCS is based, the variables manipulated by the processes $P_{1}$ and $P_{2}$ are viewed as passive agents that react to actions performed by the processes. The description of the variables used in Peterson's algorithm as processes can be done as follows:
\begin{enumerate}
	\item The process representing the shared boolean variable $b_{1}$ has two states and its behaviour can be represented by the following CCS expressions:\\
				\begin{equation*}\label{b1_imp}
				    \begin{array}{lcl}
							B1f = \overline{b1rf}.B1f + b1wf.B1f + b1wt.B1t \\
							B1t = \overline{b1rt}.B1t + b1wf.B1f + b1wt.B1t			  
						\end{array}
				\end{equation*}
	      Similarly for the process describing the behaviour of the variable $b_{2}$:\\
	      \begin{equation*}\label{b2_imp}
				    \begin{array}{lcl}
							B2f = \overline{b2rf}.B2f + b2wf.B2f + b2wt.B2t \\
							B2t = \overline{b2rt}.B2t + b2wf.B2f + b2wt.B2t,		  
						\end{array}
				\end{equation*}
	      where the pattern for the channel name is $b<i><x><y>$, with
	      \begin{itemize}
					\item $i\in\left\{1,2\right\}$ for the process ID
					\item $x\in\left\{r,w\right\}$ for the type of operation (read or write)
					\item $y\in\left\{f,t\right\}$ for the variable value to be written or read (false or true)
				\end{itemize}
	\item The process representing the variable $k$ has two states, denoted by the constants $K_{1}$ and $K_{2}$, because the variable $k$ can only take one of the two values 1 and 2, and its CCS representation is as follows\\
				\begin{equation*}\label{k_imp}
				    \begin{array}{lcl}
							K1 = \overline{kr1}.K1 + kw1.K1 + kw2.K2 \\
							K2 = \overline{kr2}.K2 + kw2.K2 + kw2.K2,		  
						\end{array}
				\end{equation*}
				where the pattern for the channel name is $k<x><n>$, with
			  \begin{itemize}
					\item $x\in\left\{r,w\right\}$ for the type of operation (read or write)
					\item $n\in\left\{1,2\right\}$ for the value to be written or read
				\end{itemize}
\end{enumerate}

The final step is the CCS formalisation of the behaviour of the processes $P_{1}$ and $P_{2}$. The process behaviour outside of the critical region can be ignored and the focus can be put on the process entering and exiting the critical section. For simplicity, an assumption is made that the processes cannot fail or terminate within the critical section. Under these assumptions, the initial behaviour of the process $P_{1}$ can be described by the following CCS expression:\\
				\begin{equation*}\label{p1_imp}
				    P1 = \overline{b1wt}.\overline{kw2}.P11,
				\end{equation*}
				where $P11$ models the while loop (with short-circuit evaluation):
				\begin{equation*}\label{p11_imp}
				    P11 = b2rf.P12 + b2rt.\left(kr2.P11 + kr1.P12\right)
				\end{equation*}
				and $P12$ models the critical section:
				\begin{equation*}\label{p12_imp}
				    P12 = enter1.exit1.\overline{b1wf}.P1
				\end{equation*}

The behaviour of the process $P_{2}$ can be described with CCS expressions in the similar manner:\\
				\begin{equation*}\label{p2_imp}
				    \begin{array}{lcl}
							P2 = \overline{b2wt}.\overline{kw1}.P21 \\
							P21 = b1rf.P22 + b1rt.\left(kr1.P21 + kr2.P22\right)\\
							P22 = enter2.exit2.\overline{b2wf}.P2	  
						\end{array}
				\end{equation*}

Finally, the CCS process term representing the whole Peterson's algorithm consists of the parallel composition of the terms describing the two processing running the algorithm and of those describing the variables. Since we are only interested in the behaviour of the algorithm pertaining to the access to, and exit from, their critical sections, we shall restrict all the communication channels that are used to read from, and write to, the variables. That set of restricted channel names is 
\begin{equation*}
	L = \left\{b1rf,b1rt,b1wf,b1wt,b2rf,b2rt,b2wf,b2wt,kr1,kw1,kr2,kw2\right\}
\end{equation*}

Assuming that the initial value of the variable $k$ is 1, our CCS description of Peterson’s algorithm is therefore given by the term:

\begin{equation}\label{pet_imp_full}
	PETERSON \stackrel{def}{=} \left(B1f|B2f|K1|P1|P2\right)\backslash L
\end{equation}

\subsubsection{Testing.} Testing the preservation of the mutual exclusion property is one of the approaches that can be used to establish the correctness of the Peterson's algorithm. A test is a finite rooted LTS over the set of actions $Act\cup\left\{\overline{bad}\right\}$, where $bad$ is a distinguished channel name not occurring in $Act$. The idea is that the test would act as a monitor process that 'observes' the behaviour of a process and reports an error in case of an occurrence of an undesirable situation by performing a $bad$-labelled transition. Assuming that the monitor process outputs 'bad' when it discovers that two enter actions have occurred without intervening exit, a CCS process describing this behaviour is:
\begin{equation*}\label{mut_test}
  \begin{array}{lcl}
  	MutexTest = \overline{enter1}.MutexTest1 + \overline{enter2}.MutexTest2 \\
		MutexTest1 = \overline{exit1}.MutexTest + \overline{enter2}.\overline{bad}.0\\
		MutexTest2 = \overline{exit2}.MutexTest + \overline{exit1}.\overline{bad}.0
	\end{array}
\end{equation*}

Now, in order to check whether process $PETERSON$ ensures mutual exclusion, it is now sufficient to let it interact with $MutexTest$ and see if the resulting system
\begin{equation}\label{pet_test}
	\left(PETERSON|MutexTest\right)\backslash M,
\end{equation}
where 
\begin{equation*}
	\left\{enter1,enter2,exit1,exit2\right\},
\end{equation*}
can initially perform the action $\overline{bad}$.

Indeed, the LTS of the CCS expression (\ref{pet_test}) generated by our tool does not have states which afford $bad$ transitions. This proves that Peterson's algorithm ensures mutual exclusion.