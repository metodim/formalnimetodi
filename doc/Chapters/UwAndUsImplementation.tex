\section{Hennessy-Milner logic and implementation of the 'strong until' and 'weak until' operators}
\label{sec:hml}

Henessy-Milner logic \cite{HennessyMilner} is a multimodal logic used to characterize the properties of a system which describe some aspects of the system's behaviour. Its syntax is defined by the following BNF grammar \cite{ModellingAndAnalysis}:
\begin{equation}\label{eq:hml_bnf}
\phi ::= \mathit{tt} \hspace{1 mm} | \hspace{1 mm} \mathit{ff} \hspace{1 mm} | \hspace{1 mm} \neg\phi \hspace{1 mm} | \hspace{1 mm}\phi\wedge\phi \hspace{1 mm} |
\hspace{1 mm} \phi\vee\phi | \left\langle a\right\rangle \phi \hspace{1 mm} | \hspace{1 mm} \left[a\right]\phi \hspace{1 mm}
\end{equation}

A single Hennessy-Milner logic formula can only describe a finite part of the overall behavious of a process. Therefore, the Henessy-Milner logic was extended to allow for recursive definitions by the introduction of two operators: the so called 'strong until' operator $U^{s}$ and the so called 'weak until' operator $U^{w}$. These operators are expressed as follows \cite{ReactiveSystems}:

\begin{equation}
	\begin{array}{lcl}
		F \hspace{1 mm} U^{s} \hspace{1 mm} G \stackrel{min}{=} G \vee \left(F \wedge \langle Act \rangle tt \wedge \left[Act\right]\left(F \hspace{1 mm} U^{s} \hspace{1 mm} G\right)\right)\\
		F \hspace{1 mm} U^{w} \hspace{1 mm} G \stackrel{max}{=} G \vee \left(F \wedge \left[Act\right] \left(F \hspace{1 mm} U^{w} \hspace{1 mm} G\right)\right)
	\end{array}
\end{equation}

The BNF grammar describing the set of HML formulas with recursion is as follows \cite{HMLRecursion}:

\begin{equation}\label{eq:hmlrec_bnf}
\phi ::= tt \hspace{1 mm} | \hspace{1 mm} ff \hspace{1 mm} | \hspace{1 mm} \neg\phi \hspace{1 mm} | \hspace{1 mm}\phi\wedge\phi \hspace{1 mm} |
\hspace{1 mm} \phi\vee\phi | \left\langle a\right\rangle \phi \hspace{1 mm} | \hspace{1 mm} \left[a\right]\phi \hspace{1 mm} | \hspace{1 mm} X | \hspace{1 mm} min\left(X,\phi \right) \hspace{1 mm} | \hspace{1 mm} max\left(X,\phi \right) \hspace{1 mm}
\end{equation}
where $X$ is a formula variable and $min\left(X,\phi\right) \hspace{1 mm}$ (respectively $max\left(X,\phi\right) \hspace{1 mm}$) stands for the least (respectively largest) solution of the recursion equation $X = \phi$.

\subsection{HML parsing}
Our implementation of the Hennessy-Milner logic works as follows: For a given HML expression and a labeled transition system, we should get an output whether that expression is valid for the corresponding labeled graph. One HML expression can be made of these set of tokens \{"AND", "OR", "UW", "US", "NOT", "[", "]", "$\langle$", "$\rangle$", "TT", "FF", "(", ")", "$\{$", "$\}$", ","\}

The first part of this process is called tokenization. Tokenization is the process of demarcating and possibly classifying sections of a string of input characters. The resulting tokens are then passed on to some other form of processing.

The process can be considered as a sub-task of parsing input. As the tokens are being read they are proceeded to the parser. The parser is a LR top-down parser. This parser is able to recognize a non-deterministic grammar which is essential for the evaluation of the Hennessy-Milner expression. As the parser is reading the tokens, thus in a way we “move” through the graph and determine if some of the following steps are possible. Every condition is in a way kept on stack and that enables later return to any of the previous conditions. The process is finished when the expression is processed or when it is in a condition from which none of the following actions can be taken over.

\subsection{$U^{w}$ and $U^{s}$ implementation}
The implementation of the $U^{w}$ and $U^{s}$ operators was done as follows. First we get the current state which is the state that contains all the nodes that satisfied the previous actions. For example if we have expression 
\begin{equation*}
	\langle a\rangle\langle a\rangle TT \hspace{1 mm} U^{s} \hspace{1 mm} \langle b\rangle TT, 
\end{equation*}
then we get all the nodes that we can reach, starting from the start node, with two actions “a”. When we get to the “Until” operation, in this case $U^{s}$, we take the start state and check if we can make an action $b$ from some node. If we cannot do the action $b$, then we repeat the process, do action $a$ again and check if can we do action $b$. This process is being repeated until we come to a state in which we can't do action a from all nodes in that state.

In the end we check the operator's type (strong or weak). If the operator is strong, then only one node in its state is enough. If it is weak, we check if there are no nodes in its new state or if we can get from the starting node to some of its neighbors through the action $b$. 

